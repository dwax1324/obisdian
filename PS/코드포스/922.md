---
tags:
  - 코드포스
  - ps
---
https://codeforces.com/contest/1918
코드포스 섹션의 첫 글이다.
일주일에 한 번? 정도 2시간을 온전히 투자해서 문제를 풀어보고 남는 시간에 틈틈히 에디토리얼을 보면서 A~D업솔빙을 해볼 생각이다. dotorya선생님께서 업솔빙에 시간을 더 쓰라고 하셨다. 아무래도 올해 코드포스랑 결판을 내야겠다. 백준에서 4000문제 이상 풀었는데 코드포스 그린은 조금 쪽팔리잖아? 어쨋든 취업하려면 코테도 볼꺼니까 명목도 있고 말이야. 근데 이 ps라는게 말이지.. 빨리 취업하고 맘편히 하고 싶다. 개발자라면 수학도 잡고 있어야 하는게 맞다. 수학 쓸 일이 적은 웹 개발자가 되고 싶은 나는 코드포스를 하면서라도 수학,그리디,애드혹,dp의 즐거움을 느껴보고 싶다. 응 ~ mathforces로 대가리 깨지고 빡종~
# A. Brick Wall

### 문제
$1*k$ 의 벽돌이 주어졌을 때 이걸 가로 혹은 세로로 놓을 수 있다. k는 마음대로 설정 가능.
(가로로 놓은 블럭 - 세로로 놓은 블럭)의 최댓값을 찾는 문제.


### 해설

우리가 찾는 정답 $ans$는 $가로로 놓인 블럭 - 세로로 놓인 블럭$ 으로 계산할 수 있다.
$k$의 최솟값이 2이므로, $ans$는  $n*⌊m/2⌋$을 넘을 수 없다.
정답을 최댓값으로 만들 수 있을까?
$m$이 짝수라면 간단하게 $1 * 2$ 짜리 블럭  $m/2$개를 놓아주면 된다.
$m$이 홀수라면 마지막에 3개의 공간이 남는데, 이 땐 그냥 마지막에 $1*3$ 크기의 블럭을 놓아주면 된다.
따라서 $ans$는 항상 최댓값, $n*⌊m/2⌋$를 달성할 수 있다.

### 후기

a번부터 그냥 막혔다
막힌 이유 
가로로 놓은 블럭 - 세로로 놓은 블럭의 절댓값인줄 착각했다. 즉, 문제 이해를 못했다.
만 명이 넘게 통과 하는데 나는 코드에 손을 대지도 못했다.
나의 심각성을 알게 됐다.
노코드, 문제 이해 및 설계를 반복훈련 하는 연습을 해야겠다.
평균의 속도로 정확히 한 번의 제출로 통과하는 것
하 너무 현타 왔다 이 때
사실 A,B까지는 프로그래밍 지식을 크게 요구하지도 않고 그냥 "너 사람 맞니?"이 정도의 느낌인데 여기서 막히니까 진짜 죽고싶었다.


```java

static void solve(int T, FastScanner sin, PrintWriter sout) {
	for (int tt = 1; tt <= T; tt++) {
		int a = sin.nextInt();
		int b = sin.nextInt();
		sout.println(a*(b/2));
	}
}

```













# B. Minimize Inversions

### 문제 설명

Inversion(역전, 자리바꿈)이란 두 원소의 자리가 바뀌었음을 의미한다. 좀 더 포말하게 말하면, 
$i < j$일 때 $a_i > a_j$ 이어야한다.
길이 $n$의 두 배열이 주어진다. 두 배열은 순열이다.
두 배열의 같은 인덱스 $a_i,\ b_i$를 선택하여 각각 $a_j,\ b_j$ 와 자리를 마음껏 바꿀 수 있다. 꼭 두 배열 동시에 자리바꿈을 해야한다는 것을 주의하라.
inversion의 수가 가장 적게 되도록 순서를 바꿔보자. 가능한 답 중 아무거나 출력한다.

### 해설

여러 케이스로 나눠 보자.
1. $A_i < B_i\  \&\&\  A_j > B_j$  인 경우, 혹은 $A_i > B_i\  \&\&\  A_j < B_j$ 인 경우. 순서를 어떻게 바꿔도 inversion이 1개 생길 수 밖에 없다.
2. $A_i < B_i\  \&\&\  A_j < B_j$  인 경우, 혹은 $A_i > B_i\  \&\&\  A_j > B_j$ 인 경우. $i, j$ 의 순서를 지켜주는 것이 옵티멀하다.
배열 A,B가 있을 때, 하나의 배열을 정렬시켜줌으로써 2번경우를 inversion을 소멸시킬 수 있다. 1번 경우는 불가피하기 때문에 2번 경우만 고려해주면 된다.
![[Screenshot 2024-02-01 at 12.59.50.png]]
에디토리얼 넘 어렵게 써졌는데 댓글에 친절한 설명이.. 다행쓰
### 소감

왠지 그럴거 같은 느낌적인 느낌
어떻게 푸는지는 알거 같은데
증명을 해보라고 하면 딱히??? 못하겠다
논리적인 생각을 하는 연습을 더 해야할듯

# C. XOR-distance

### 문제
$a,b,r$ 이 주여졌을 때 $|a\oplus x| - |b\oplus x|$ 의 최솟값을 찾는 문제.($0 ≤ x ≤ r$)


### 해설


### 소감

살짝 멘붕 오다가 아이디어 관찰을 하긴 했는데
일단 여러 케이스로 나누어 보았음

1. 비트 문자열 기준 $a_i$ 와 $b_i$ 가 같을 때($0,0\ 혹은 \ 1,1$ 일 때) , 두 digit을 xor시켜도 결과는 똑같다.(비트 문자열에서 $a - b$ 를 하면 각 자릿수르 빼기면 하면 되니까, $1-1, 0-0$은 똑같다)
2. $1,0 혹은 0,1$ 일 때, xor을 시켜주면 $0,1\ 혹은\ 1,0$이 된다. 다른 말로, xor을 시켜서 1을 갖게 되는 쪽의 값이 커진다. $a-b > 0$이라면  a를 줄여주는게 좋겠지?
3.  어쨋든 목표는 $|a-b|$의 값을 최소로, $0$에 가깝게 맞추는 것이다. 

여기까지 생각은 했는데, $0 ≤ x ≤ r$ 이라는 조건과 구체적으로 어떻게 구현할 것인가?에서 막혔다. 당장 생각나는건 브루트포스로 0,1인 부분들을 찾아서 비교해 보는 것인데, 수가 $2^{63}$ 까지 되고 그렇다면 63개에서 1개 고르고.. 2개 고르고.. 63개 고르고.. 까지 가야한다는 것인데? 

그러니까 막히는 부분이 그거다. MSB에서부터 하나씩 비교하면서 바꿔보면 되긴 하는데 바꾸고 복구를 시켜야 하는가? 경우의 수가 너무 많은데??

어떤 최적의 루트가 있거나 dp인가?

