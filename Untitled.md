값을 쓰려면 어차피 값을 들고 있어야한다.

x = 3

하나의 트랜잭션에 대해서 모든 데이터는 x초안에 쓰기 작업이 완료되어야 한다.
x초를 초과한다면 장비 혹은 로직상의 결함이 있다고 생각하고 서버의 에러로 간주한다.
그 x초 동안, 들어온 값은 캐싱을 한다.

값이 캐싱되어 있다면 .. 복잡한 쿼리에 대해서는 어떻게 그 값을 반환하지? 문제가 더 복잡해질 거 같다. 캐싱을 해서 어떻게 할 수는 있어보이는데 조금 더 생각해볼거리다.

Reader와 Writer데이터베이스에서 비동기로 통신하는 방식은 분명히 좋아보인다. Writer에서 Reader로 값을 쓰는 요청을 비동기로 보냈을 때, Reader는 작업을 완료했는지, 성공했는지 등의 정보를 담아 응답을 비동기적으로 반환할 수 있다. 
잘 모르겠는 점은 두 데이터베이스간의 통신의 양이 많아지고, 결국에는 나중에 서로의 데이터가 정확한지 검증하는 대사 작업을 해야한다. 많아지는 통신의 양과 대사 작업이 얼마나 복잡도가 높을지 가늠이 잘 안되긴한다.

동기적으로 두 데이터베이스간 작업을 진행할 수도 있다. 하지만 병목현상이 생기지 않을지, Reader가 작업을 완료할 때까지 Writer는 순순히 기다릴 수 밖에 없다. 비동기적, 동기적으로 작업을 했을 때 각 작업을 비교해보는 것도 재밌어 보인다.

지금 생각해봤을 때는 동기적인 방식이 가장 좋아보인다. 

MyTransaction을 정의한다. 타임아웃을 3초로 설정한다.
1. 쓰기 요청이 들어오면 Writer db와 Reader db 동시에 값을 쓴다. 
	이 때, 변경 되어야할 값을 지역 변수로 들고 있는다.
2. 변경된 값을 Reader db에서 읽는 쿼리를 요청한다.
3. 지역변수와  Reader db에서 반환된 값이 같으면, 커밋을 한다. 아니라면, 롤백을 한다.

안전성이 중요할 때는 MyTransaction을 켜놓고 있다가, 성능이 중요할 때는 MyTransaction을 꺼놓으면.