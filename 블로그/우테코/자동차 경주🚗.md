
자동차 경주 미션이 끝났다!
자동차 경주가 나에게 준 교훈은 무엇일까? 

# 게임 설명

자동차 이름과 게임 회수를 입력 받고 게임의 결과를 보여준다.
최종 우승자와 각 회의  자동차들의 전진 거리를 보여준다
전진 or 정지는 랜덤으로 정해진다. (0~9 사이의 무작위 수가 4 이상이면 전진)

ex)
```
경주할 자동차 이름을 입력하세요(이름은 쉼표(,)를 기준으로 구분).
pobi,crong,honux
시도할 회수는 몇회인가요?
5

실행 결과
pobi : -
crong : -
honux : -

pobi : --
crong : -
honux : --

pobi : ---
crong : --
honux : ---

pobi : ----
crong : ---
honux : ----

pobi : -----
crong : ----
honux : -----

pobi : -----
crong : ----
honux : -----

pobi, honux가 최종 우승했습니다.

```

# 나는 어떠한 환경에서 이 문제를 풀었는가
### 제한된 시간
25시간. 네오피셜 25시간이었다. 연극도 있었고, 미션 사이클도 익혀야 했기 때문에 정말 너무 빠듯했다.  
딱 하루만 더 있었다면.. 하는 마음이 들었다.
### 페어 프로그래밍
페어인 커비와 함께 이 문제를 풀었다. 좋은건지 나쁜건지는 모르겠지만, 짧은 시간안에 엄청나게 많은 지식을 주입 당했다. 사실 페어프로그래밍 중반부터 내가 무슨 코드를 짜고 있는지 몰랐었다.(난 프리코스 경험이 다라고 ㅠㅠ) 그래서 어느 순간부터 driver때는 페어의 말을 그대로 받아 적기만 하고, navigator역할은 충분히 소화하지 못했던 거 같다. 지금 와서 느끼는거지만, 모르면 모른다고 확실히 이야기할 수 있어야한다. 페어프로그래밍은 두 명 다 자신의 프로그램에 대해 확실히 이해하고 있어야하고, 모른다고 어물쩡 넘어가버리면 나중에 분명히 큰 재앙이 닥친다. 모른다고 말하는 것도 물론 엄청난 용기가 필요하다. (시간의 압박이 있는데 당당히 모르겠다고 말할 수 있는 사람이 얼마나 될까?) 욕심을 줄이고 요구사항만 만족하도록 제출해도 됐지만, 첫 미션이기하고 둘 다 의욕이 넘쳤고 욕심도 넘쳤다. 첫주차는 집에 도착하면 항상 새벽 0시가 넘었다.
지금 와서 보니 내가 작성한 코드에 원시값 포장, 주생성자와 부생성자, 팩토리 메서드, 일급 컬렉션, 테스트하기 좋은 코드 등의 엄청난 개념들이 숨어있었다. 페어와 나의 눈높이가 달랐던 것이다. 

# DTO
DTO에 관한 고민을 정말 많이 했다. 사실 MVC패턴이라면 당연히 DTO를 사용해야 하는 줄 알았다. (작은 프로그램에서 View가 Domain을 직접적으로 의존해도 괜찮은지 몰랐다) 아무튼 DTO를 사용하면서 DTO를 어떻게 사용해야 할까에 대한 고민을 정말 많이 했다. 예를 들어 View에서 DTO를 만들어서 Model로 보낼 때 Controller에서 DTO를 풀어서 각 객체가 받아야할지, 아니면 Model에서 각 객체가 DTO를 받아서 DTO를 풀
어야 할지, 그리고 Controller에서 DTO를 생성해도 되는지.. 크게 이 세 부분에 대해 고민했었던 거 같다. 

```
dto를 직접적으로 의존하지 않고 마지막에 말씀하신것처럼 날것의 데이터를 각 객체에게 넘겨주는 방법도 있을것 같습니다.

여러가지 경우가 있을 것 같은데  
지금의 경우 Cars의 생성하는, dto를 이용한 특정 구현세부사항을 Cars내에 구현해두는것이 과연 좋은 설계인지에 대한 의문을 가지게 되는 것 같습니다.
```

일단 DTO가 계층간의 데이터 전송을 위한 객체이기 때문에 계층간의 이동을 위해서라면 어디서 생성되든 문제 없다고 느꼈고, DTO를 각 객체가 받아서 사용하는 것보단 Controller단에서 한번 풀어서 raw data를 넘겨 주는 것이 조금 더 바람직하다고 생각했다.

# TDD
예전에 TDD영상 한 번 본게 다인데, 빠듯한 일정속에서 절반 정도 TDD를 했다. 페어인 커비가 tdd에 대해 잘 알고 있었던 모양이다. 나는 레드,그린,리펙터까지 밖에 모르고 있었는데, 커비가 컴파일 에러를 잡고 그린으로 가야한다고 지적해줬다. 재야의 고수였다.

# 원시값 포장

진짜 할 말이 많은 주제다. 이 원시값 포장 때문에 엄청 고생했다. 원시값 포장을 잘 모른다면 https://tecoble.techcourse.co.kr/post/2020-05-29-wrap-primitive-type/ 과 https://engineerinsight.tistory.com/37 를 읽어보자.
그럼 어느정도 원시값을 포장하는 것이 바람직하다고 생각이 들 것이다. 문제는 HOW? 였다. 
```
distance의 increase를 car 외부에서 get한 다음 호출하면 어떤일이 발생 할 수 있을까요?
```
위와 같은 리뷰를 받았었다. 미션을 수행하면서 원시값을 나름 포장한다고 포장했는데, 포장된 객체가 스스로 상태를 바꿀 수 있기 때문에 문제가 발생했다. 미션을 수행하면서 당연히 거리를 증가하는 책임은 Distance에게 있으니 Distance한테 거리를 증가하라는 메시지를 보내려고 했다. 하지만 Car에서 Distance를 반환하기 때문에 car.distance.increase()가 가능했다. 이는 디미터법칙 위반이고 책임이 분산되어 좋지 않은 코드다.
여기서 두 가지 해결 방법이 있다.
1. Car내부에서는 Distance가 스스로 상태를 결정할 수 있도록하고(가변적) Car 외부에서 거리가 필요로 할 때 int형을 반환한다.
2. 값 객체를 사용한다.
사실 2번으로 하고 싶지 않았다. 왜냐하면 나는 Distance를 스스로 상태를 능동적으로 정할 수 있는 객체로 바라봤기 때문이다. Car에서 Distance한테 거리를 증가하라는 메시지를 보내고 싶었고, "값 객체로 할거면 원시형이랑 무슨 차이지? 그냥 검증로직만 뺄 수 있는거 아닌가?" 라는 생각도 들었었다. 
실제로 이 부분이 이해가 안가서 리뷰어님께 DM를 보내 물어봤다. 
```
1. 불변인 Distance객체에 increase하라는 메시지를 보내라는 것이 어떤 의미인지 잘 모르겠습니다.
값 객체가 스스로 increase를 할 수가 있나요?
```

```
Distance의 increase가 내부 값을 변경할 수 없지만 새로운 Distance를 생성해보는것을 말씀드린것이었습니다
```
이런 답변을 받았다. 사실 여기서 생각이 완전히 막혀버렸다. '값' 객체는 객체보다 값에 초점이 맞춰져 있기 때문에 우리가 값을 다루는 것처럼 굉장히 수동적일 것이라고 억측하고 있었다. Distance는 '값' 객체, Value Object인데 그 안에 increase 메서드 자체가 있다는 게 이해가 안됐다. 아무리 새로운 객체를 생성하더라도, 값과 비슷한 성질이기 때문에 외부에서 조작해줘야한다는 생각이 은연중에 있었다.
이런 고민을 하던 중 연극 준비를 하고 있었는데 조원들에게 물어봤더니 리건이 


![[Screenshot 2024-02-25 at 03.55.20.png]]
![[Screenshot 2024-02-25 at 03.55.53.png]]
비밥님은 천사시다.
# 안녕 난 랜덤이야




# 의미있었던 리뷰들