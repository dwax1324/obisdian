
```
corePoolSize : 풀 내 최소로 가지고 있는 스레드 개수 - 미리 준비한 스레드를 통해 생성에 드는 시간 방지
maximumPoolSize : 최대로 가질수 있는 스레드 개수 - 너무 많은 스레드가 생성되어 리소스를 많이 차지 하는걸 방지
keepAliveTime : 작업 후 스레드가 남아있는 시간 - 스레드가 삭제 & 생성되는데 드는 시간 방지
timeUnit : keepAliveTime 의 단위

rejectedExecutionHandler : 거절된 실행을 어떻게 처리할지 지정하는 핸들러

CallerRunsPolicy : Queue,Thread 가 전부 작업 상태일 시, Main 스레드도 작업을 수행한다. ( 10 개 전부 수행 )
AbortPolicy : 전부 작업 상태 시, RejectedExecutionException 발생시킴 ( 4 + 2 개만 수행 )
DiscardPolicy : 전부 작업 상태 시, 조용히 작업 거부 ( 4 + 2 개만 수행 )
DiscardOldPolicy : 전부 작업 상태 시, 예전에 대기하고 있는 작업을 제거 후 교체한다 - current Queue 내 작업이 계속 달라짐 ( 4 +2 개만 수행 )
```

생각해볼만한 질문 남겨주셔서 감사해요~



`corePoolSize` 매일 평균 요청 수로 설정할 것 같습니다~ 
`maximumPoolSize` 는 컴퓨터나 사용중인 인스턴스의 사양에 따라 결정할 것 같아요. 물리적인 제약이 없다면 서비스의 최대 이용자의 수을 파악하고 조금 더 여유롭게 최대치로 설정할 것 같습니다. 
`keepAliveTime, timeUnit` 은 요청의 패턴을 파악하여 생성과 소멸에 드는 자원을 아껴볼 수 있을 것 같아요.


```
RejectedExecutionHandler

CallerRunsPolicy : Queue,Thread 가 전부 작업 상태일 시, Main 스레드도 작업을 수행한다. ( 10 개 전부 수행 )
AbortPolicy : 전부 작업 상태 시, RejectedExecutionException 발생시킴 ( 4 + 2 개만 수행 )
DiscardPolicy : 전부 작업 상태 시, 조용히 작업 거부 ( 4 + 2 개만 수행 )
DiscardOldPolicy : 전부 작업 상태 시, 예전에 대기하고 있는 작업을 제거 후 교체한다 - current Queue 내 작업이 계속 달라짐 ( 4 +2 개만 수행 )
```


`RejectedExecutionHandler` 은 기본적으로 `AbortPolicy` 를 사용하고 있고  실행이 거절됐을 경우 이를 어떻게 처리할지 결정 하는군요 ㅎㅎ. 알고는 있지만 정리는 안됐던 내용인데 공유해주셔서 감사합니다~!

`CallerRunsPolicy` 는 조금  사용하기 위험하다고 생각해요. 메인 스레드가 작업을 처리하게 되면서 컴퓨터 성능에 영향을 주어 결국에는 사용자 경험에 부정적인 영향을 끼칠 수 있을 것 같아요. 여러번의 테스트와 컴퓨터에 무리가 가지 않는 선까지 적절히 조절할 수 있다면 괜찮을거 같기도합니다.  시간이 걸려도 응답을 받고 싶은 사용자 입장에서 원하는 결과를 얻을 수 있으니깐요. 검색해보니 쓰로틀링을 쉽게 구현할 수 있는 방법 중 하나라고 하네요!

`DiscardPolicy` 나 `DiscardOldPolicy` 를 사용하면 조용히 작업을 거부하기 때문에 이에 대한 예외 상황을 처리하기가 까다로울 거 같아요. 명시적으로 예외를 던지는 그리고 기본적으로 사용되는`AbortPolicy` 을 채택할 거 같습니다.


`corePoolSize`  = 평균 동시 요청 수

`maximumPoolSize` 는 컴퓨터나 사용중인 인스턴스의 사양에 따라 결정할 것 같아요. 물리적인 제약이 없다면 서비스의 최대 동시 요청 수을 파악하고 조금 더 여유롭게 설정할 것 같습니다. 

`keepAliveTime, timeUnit` 은 요청의 패턴을 파악하여 생성과 소멸에 드는 자원을 아껴볼 수 있을 것 같아요. 서비스 특성상 한 번 요청이 시작되면 연달아서 요청이 들어오고 그 이후로는 사용하지 않을 거 같습니다 (궁금한 것이 생기면 검색 후 미사용). 튜닝을 해야한다면 생성과 소멸로 인한 부작용과 스레드의 수가 최댓값을 넘을 때의 부작용을 적절히 저울질할 수밖에 없을 거 같습니다.

일단 가용 가능한 자원이 적기 때문에 `FixedPool`은 사용하지 않을거 같아요. 거절 정책은 `AbortPolicy`를 사용하여, 사용자에게 빠른 응답을 줄 수 있도록 하는게 나아보입니다.

사용자가 있고 모니터링한 데이터가 있을 때 변수들을 적절히 조절해가며 최적값을 찾아볼 거 같지만 현재는 그냥 기본설정 쓸 거 같네요 ㅎ_ㅎ

만약 사용자 수가 50명이면 동시 요청 수는 더 적을 것이기 때문에 
`AbortPolicy`
`fixedPool: 25, maximumPoolSize: 75, keepAliveTime 30, timeUnit: SECONDS`
일단 지금의 판단으로는 위와 같이 설정해볼 것 같습니다.

# 세션은 언제 생성해야 하는가

이 부분은 제가 따로 생각을 하지 못했네요.  `Controller` 라는 용어가 주는 의미가 싫어서 1~2단계에서 `Resolver` 를 사용했습니다. 

제가 학습하며 배운 WAS의 기본적인 구조는
1. 요청과 응답 포워딩  <= 현재의 Tomcat 클래스가 담당
2. (처리가 필요한 응답이라면) 처리 <= 현재의 Controllers, 이전의 Resolver가 담당
라고 생각했어요.

그래서 HTTP 요청과 응답을 제외한 동적 처리를 해주는 클래스라고 생각했고 여기서 세션의 생성 위치 같은 구조적인 부분은 생각하지 못했던 거 같습니다. 