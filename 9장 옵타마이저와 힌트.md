
`EXPLAIN` 이라는 명령으로 쿼리의 실행 계획을 알 수 있다.

# 쿼리의 실행 과정

1. SQL문을 파싱한다 (SQL 파싱 단계) (mysql 엔진)
	1. `SQL Parsing` 과정. `SQL Parser` 라는 모듈로 처리함.
	2. `SQL 파스 트리` 생성
2. 파싱 정보를 확인하며 최적화된 쿼리 실행 방법 선택 (최저고하 및 실행 계획 수립 단계) (mysql엔진, 특히 옵티마이저)
	1. 불필요한 조건 제거 및 연산 단순화
	2. 테이블 조인이 있는 경우 테이블 읽기 순서 결정
	3. 테이블의 조건과 인덱스 통계 정보를 이용해 인덱스 결정
	4. 임시 테이블 필요 여부, 레코드 재가공 여부 결정
	5. 이 단계가 끝나면 `실행 계획`이 만들어진다.
3. 방법 실행 (실행 과정) (mysql엔진 + 스토리지 엔진)
	1. `실행 계획`을 토대로 계획을 실행한다.

# 옵티마이저의 종류

`Cost-based Optimizer, CBO` , `Rule-based Optimizer, RBO` 로 나뉘어짐


1. CBO: 쿼리를 처리하기 위한 여러가지 방법을 만들고 비용을 산출한다. 이 중 최소로 소요되는 방식을 선택해 쿼리를 실행한다.
2. RBO: 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립한다. 같은 쿼리에는 항상 같은 실행방법이 만들어진다.데이터는 불규칙적이기 때문에 RBO는 거의 사용되지 않는다.




# 풀테이블 스캔, 풀인덱스 스캔

MySQL 옵티마이저이 풀테이블 스캔을 선택할 때:
1. 레코드 건수가 너무 작아서 테이블 스캔이 더 빠른경우
2. `WHERE` 절이나 `ON` 절에 적절하게 인덱스를 이용할 수 없는 경우
3. 조건 일치 레코드 건수가 너무 많은 경우

풀테이블스캔은 비용이 많이 드는 작업이라서 대부분의 DBMS는 풀 테이블 스캔을 실행할 때 한꺼번에 여러개의 블록이나 페이지를 읽어온다.
그러나, MySQL에는 풀테이블 스캔을 할 때 한번에 몇 개의 페이지를 읽어올지 설정하는 시스템 변수가 없다.
그러나, InnoDB스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 `Read ahead` 작업이 자동으로 시작된다. 리드 어헤드란 읽기가 필요한 데이터를 미리 예측해서 InnoDB 버퍼 풀에 미리 가져다 두는 것을 의미한다.

풀테이블 스캔이 실행되면 처음 몇개의 데이터 페이지는 `foreground` 였다가, `background`로 넘겨진다. 백그라운드 스레드는 4개, 8개씩 ㅔㅍ이지를 읽으면서 계속 그 수를 증가시킨다. 최대 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장해둘 수 있다.

`innodb_read_ahead_threshold` 시스템 변수를 이용해 언제 리드 어헤드를 시작할지 임계값을 설정할 수 있음. 
풀인덱스 스캔에서도 리드 어헤드는 똑같이 적용된다. 

`SELECT COUNT(*) FROM employees;`
는 풀인덱스 스캔을 사용할 확률이 높다.
풀테이블 스캔을 이용하면 모든 데이터를 읽어야하기 때문에 건수만 필요한 이 경우에 풀인덱스 스캔을 사용하면 디스크 읽기 횟수를 줄일 수 있다.

반대로, 다음과 같은 경우는 당연히 풀테이블 스캔을 사용한다.
`SELECT * FROM employees;`


# 병렬 처리

병렬처리란 `하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리한다`는 뜻이다.

`innodb_parallel_read_threads` 라는 시스템 변수를 사용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해 처리할지 정할 수 있다.

스레드의 개수가 CPU의 코어 개수를 넘어서는경우 오히려 성능이 떨어질 수 있으니 주의.

# ORDER BY 처리(Using filesort)


정렬을 처리하는 방법은
1. 인덱스를 이용하는 방법
	1. 장점: `INSERT`, `UPDATE`, `DELETE` 를 할 때 매우 빠름 (이미 정렬되어 있기 때문)
	2. 단점: 부가적인 인덱스 작업이 필요하므로 느림. 디스크 공간이 필요. 메모리 추가 필요.
2. 쿼리가 실행될 때 `Filesort`를 이용하는 방법
	1. 정렬해야할 레코드가 많지 않으면 메모리에서 정렬이 되므로 충분히 빠르다.
	2. 정렬이 쿼리시 처리되므로 쿼리의 응답 속도가 느리다.
이 있다.


인덱스 정렬은 충분히 좋지만, 모든 정렬을 인덱스 정렬로 사용할 수 없다.
1. 기준이 많아 요건별로 모든 인덱스를 생성 불가한 경우
2. `GROUP BY`, `DISTINCT` 와 같이 처리의 결과를 정려해야하는 경우
3. `UNION`의 결과와 같이 임시 테이블의 결과를 다시 정렬해야하는 경우
4. 랜덤하게 결과 레코드를 가져와야 하는 경우

실행계획의 `Extra` 컬럼에 `Using filsort`메시지 표시 여부로 별도로 정렬을 처리했는지 알 수 있다.

# 소트 버퍼

`Sort Buffer`란 MySQL이 정렬을 수행하기 위해 별도로 할당받는 메모리 공간이다.
